"use strict";(self.webpackChunkbeauty_docs=self.webpackChunkbeauty_docs||[]).push([[6227],{5925:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>t,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"Advanced/di","title":"Dependency Injection (DI)","description":"Beauty Framework uses a clean, explicit, and fully modular Dependency Injection system based around static DI classes. All service bindings are configured through a single entrypoint \u2014 the DI::configure method in your app or module. No global calls, no magic autowiring \u2014 just straightforward dependency wiring you always control.","source":"@site/docs/3-Advanced/di.md","sourceDirName":"3-Advanced","slug":"/Advanced/di","permalink":"/docs/Advanced/di","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Advanced Topics Overview","permalink":"/docs/Advanced/overview"},"next":{"title":"Events & Listeners","permalink":"/docs/Advanced/events"}}');var o=i(4848),r=i(8453);const t={sidebar_position:1},c="Dependency Injection (DI)",a={},l=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"How to Register Bindings (THE ONLY WAY!)",id:"how-to-register-bindings-the-only-way",level:2},{value:"How Dependencies Are Injected",id:"how-dependencies-are-injected",level:2},{value:"Module Example",id:"module-example",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"dependency-injection-di",children:"Dependency Injection (DI)"})}),"\n",(0,o.jsxs)(n.p,{children:["Beauty Framework uses a clean, explicit, and fully modular Dependency Injection system based around static DI classes. All service bindings are configured through a single entrypoint \u2014 the ",(0,o.jsx)(n.code,{children:"DI::configure"})," method in your app or module. No global calls, no magic autowiring \u2014 just straightforward dependency wiring you always control."]}),"\n",(0,o.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"DI class"}),": Every app/module can (and should) define its own ",(0,o.jsx)(n.code,{children:"DI"})," class (usually at ",(0,o.jsx)(n.code,{children:"App\\Container\\DI"})," or ",(0,o.jsx)(n.code,{children:"Module\\YourModule\\Container\\DI"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"configure method"}),": All bindings go inside the static ",(0,o.jsx)(n.code,{children:"configure(ContainerManager $container)"})," method. No other place, ever."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Bindings"}),": You bind interfaces, classes, or names to concrete implementations or closures."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Resolution"}),": All controller/service dependencies are injected by the framework automatically based on your bindings \u2014 you never fetch dependencies from the container manually."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"how-to-register-bindings-the-only-way",children:"How to Register Bindings (THE ONLY WAY!)"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Create a DI class if it doesn't exist:"})}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-php",children:"namespace App\\Container;\n\nuse Beauty\\Core\\Container\\ContainerManager;\nuse Psr\\Log\\LoggerInterface;\nuse Spiral\\RoadRunner\\Logger;\n\nclass DI\n{\n    public static function configure(ContainerManager $container): void\n    {\n        // Register logger as singleton via factory closure\n        $container->singleton(LoggerInterface::class, fn() => new Logger('stdout'));\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Use ",(0,o.jsx)(n.code,{children:"$container->bind(interface, implementation)"})," for regular bindings."]}),"\n",(0,o.jsxs)(n.li,{children:["Use ",(0,o.jsx)(n.code,{children:"$container->singleton(interface, closure)"})," for singletons \u2014 the closure will be called once."]}),"\n",(0,o.jsxs)(n.li,{children:["Use ",(0,o.jsx)(n.code,{children:"$container->instance(interface, $instance)"})," for ready objects."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ALWAYS"})," put your bindings in ",(0,o.jsx)(n.code,{children:"DI::configure"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"how-dependencies-are-injected",children:"How Dependencies Are Injected"}),"\n",(0,o.jsx)(n.p,{children:"You never resolve services manually. Just type-hint what you need in your constructors, and Beauty will inject it for you according to your bindings."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-php",children:"class ReportService {\n    public function __construct(LoggerInterface $logger, CacheManager $cache) {\n        // ...\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Any controller, service, or class created by the framework gets all its dependencies injected automatically."}),"\n",(0,o.jsx)(n.h2,{id:"module-example",children:"Module Example"}),"\n",(0,o.jsxs)(n.p,{children:["Each module ships with its own ",(0,o.jsx)(n.code,{children:"DI"})," class for clean isolation:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-php",children:"namespace Module\\Blog\\Container;\n\nuse Beauty\\Core\\Container\\ContainerManager;\nuse Module\\Blog\\Repositories\\PostRepositoryInterface;\nuse Module\\Blog\\Repositories\\PostRepository;\n\nclass DI\n{\n    public static function configure(ContainerManager $container): void\n    {\n        $container->singleton(PostRepositoryInterface::class, fn() => new PostRepository());\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Bind interfaces, never concrete classes \u2014 always inject abstractions."}),"\n",(0,o.jsx)(n.li,{children:"Use closures for anything that needs parameters/config/logic."}),"\n",(0,o.jsxs)(n.li,{children:["Keep all bindings together in ",(0,o.jsx)(n.code,{children:"DI::configure"})," \u2014 this is the contract for your app/module."]}),"\n",(0,o.jsx)(n.li,{children:"Never pull dependencies directly from the container (no service location!)."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"For advanced usage (factories, contextual bindings, conditional wiring), see the repo or contact the core team."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>c});var s=i(6540);const o={},r=s.createContext(o);function t(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);